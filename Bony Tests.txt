

Public Sub CheckForExistingIndexes()
    Dim db As DAO.Database
    Set db = CurrentDb
    
    Dim tbl As DAO.TableDef
    Set tbl = db.TableDefs("BonyStatement")
    
    Debug.Print "‚ïê‚ïê‚ïê INDEXES ON BonyStatement ‚ïê‚ïê‚ïê"
    Debug.Print ""
    
    Dim idx As DAO.Index
    For Each idx In tbl.Indexes
        Debug.Print "Index Name: " & idx.Name
        Debug.Print "  Primary: " & idx.Primary
        Debug.Print "  Unique: " & idx.Unique
        Debug.Print "  Fields: "
        
        Dim fld As DAO.Field
        For Each fld In idx.Fields
            Debug.Print "    - " & fld.Name
        Next
        Debug.Print ""
    Next
    
    Set tbl = Nothing
    Set db = Nothing
End Sub


Public Sub VerifyActualRowCount()
    Dim rs As ADODB.Recordset
    Set rs = CurrentProject.Connection.Execute("SELECT COUNT(*) AS Total FROM BonyStatement")
    
    Debug.Print "Total rows in BonyStatement: " & Format(rs("Total"), "#,##0")
    
    ' Also check how many with today's date
    Set rs = CurrentProject.Connection.Execute( _
        "SELECT COUNT(*) AS Total FROM BonyStatement WHERE ValueDate = #13-Jan-2025#")
    
    Debug.Print "Rows with ValueDate = 13-Jan-2025: " & Format(rs("Total"), "#,##0")
    
    rs.Close
End Sub


 Public Sub GetDetailedTableInfo()
    Dim db As DAO.Database
    Set db = CurrentDb
    
    Dim tbl As DAO.TableDef
    Set tbl = db.TableDefs("BonyStatement")
    
    Debug.Print "‚ïê‚ïê‚ïê BonyStatement TABLE INFO ‚ïê‚ïê‚ïê"
    Debug.Print "Record Count: " & Format(tbl.RecordCount, "#,##0")
    Debug.Print ""
    
    Debug.Print "Fields:"
    Dim fld As DAO.Field
    For Each fld In tbl.Fields
        Debug.Print "  " & fld.Name & " (" & GetFieldTypeName(fld.Type) & ")"
        If fld.Name = "ValueDate" Then
            Debug.Print "    ‚Üí Indexed: " & fld.Attributes And dbIndexed
        End If
    Next
    
    Debug.Print ""
    Debug.Print "Indexes:"
    Dim idx As DAO.Index
    For Each idx In tbl.Indexes
        Debug.Print "  " & idx.Name & ":"
        For Each fld In idx.Fields
            Debug.Print "    - " & fld.Name
        Next
    Next
End Sub

Private Function GetFieldTypeName(fieldType As DAO.DataTypeEnum) As String
    Select Case fieldType
        Case dbLong: GetFieldTypeName = "Long Integer"
        Case dbText: GetFieldTypeName = "Text"
        Case dbMemo: GetFieldTypeName = "Memo"
        Case dbDate: GetFieldTypeName = "Date/Time"
        Case dbDouble: GetFieldTypeName = "Double"
        Case dbCurrency: GetFieldTypeName = "Currency"
        Case Else: GetFieldTypeName = "Other (" & fieldType & ")"
    End Select
End Function

Public Sub CompareIndexedVsNonIndexed()
    Debug.Print "‚ïê‚ïê‚ïê PERFORMANCE COMPARISON ‚ïê‚ïê‚ïê"
    Debug.Print ""
    
    ' Test 1: Query that CAN use index (if exists)
    Debug.Print "Test 1: WHERE ValueDate = #13-Jan-2025#"
    Dim startTime As Double
    startTime = Timer
    
    Dim rs As ADODB.Recordset
    Set rs = CurrentProject.Connection.Execute( _
        "SELECT * FROM BonyStatement WHERE ValueDate = #13-Jan-2025#")
    
    Dim indexedTime As Double
    indexedTime = Timer - startTime
    
    Debug.Print "  Rows: " & rs.RecordCount
    Debug.Print "  Time: " & Format(indexedTime, "0.000") & " seconds"
    rs.Close
    
    ' Test 2: Query that CANNOT use index (function prevents it)
    Debug.Print ""
    Debug.Print "Test 2: WHERE DateValue(ValueDate) = #13-Jan-2025#"
    Debug.Print "  (Wrapping in function prevents index use)"
    
    startTime = Timer
    Set rs = CurrentProject.Connection.Execute( _
        "SELECT * FROM BonyStatement WHERE DateValue(ValueDate) = #13-Jan-2025#")
    
    Dim nonIndexedTime As Double
    nonIndexedTime = Timer - startTime
    
    Debug.Print "  Rows: " & rs.RecordCount
    Debug.Print "  Time: " & Format(nonIndexedTime, "0.000") & " seconds"
    rs.Close
    
    ' Compare
    Debug.Print ""
    Debug.Print "‚ïê‚ïê‚ïê RESULTS ‚ïê‚ïê‚ïê"
    Debug.Print "Indexed query: " & Format(indexedTime, "0.000") & " sec"
    Debug.Print "Non-indexed query: " & Format(nonIndexedTime, "0.000") & " sec"
    
    If nonIndexedTime > indexedTime * 5 Then
        Debug.Print ""
        Debug.Print "‚úì CONFIRMED: You have a working index on ValueDate!"
        Debug.Print "  (Non-indexed is " & Format(nonIndexedTime / indexedTime, "0") & "x slower)"
    Else
        Debug.Print ""
        Debug.Print "‚ö†Ô∏è Both queries similar speed - might not have an index"
        Debug.Print "  OR: Data is small enough that it doesn't matter"
    End If
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
CRITICAL DIAGNOSTICS TAKE 2
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'Test 1: Verify Actual Row Count

Public Sub GetTrueRowCount()
    Debug.Print "‚ïê‚ïê‚ïê ACCURATE ROW COUNT TEST ‚ïê‚ïê‚ïê"
    Debug.Print ""
    
    ' tbl.RecordCount can be unreliable - get real count
    Dim startTime As Double
    startTime = Timer
    
    Dim rs As ADODB.Recordset
    Set rs = CurrentProject.Connection.Execute("SELECT COUNT(*) AS Total FROM BonyStatement")
    
    Dim countTime As Double
    countTime = Timer - startTime
    
    Debug.Print "Actual row count: " & Format(rs("Total"), "#,##0")
    Debug.Print "Count time: " & Format(countTime, "0.00") & " seconds"
    Debug.Print ""
    
    If rs("Total") < 100000 Then
        Debug.Print "‚ö†Ô∏è WARNING: Row count is much lower than 1.5M!"
        Debug.Print "This explains the fast query performance."
    ElseIf rs("Total") > 1000000 Then
        Debug.Print "‚úì Confirmed: Over 1 million rows"
        Debug.Print "Fast query with no index is VERY unusual!"
    End If
    
    rs.Close
End Sub

'Test 2: Check if Table is Linked

Public Sub CheckIfLinkedTable()
    Dim db As DAO.Database
    Set db = CurrentDb
    
    Dim tbl As DAO.TableDef
    Set tbl = db.TableDefs("BonyStatement")
    
    Debug.Print "‚ïê‚ïê‚ïê TABLE TYPE CHECK ‚ïê‚ïê‚ïê"
    Debug.Print "Table name: " & tbl.Name
    Debug.Print "Connect string: " & tbl.Connect
    Debug.Print ""
    
    If tbl.Connect <> "" Then
        Debug.Print "‚ö†Ô∏è THIS IS A LINKED TABLE!"
        Debug.Print "Source: " & tbl.Connect
        Debug.Print ""
        Debug.Print "The indexes might exist on the source database,"
        Debug.Print "but they don't show in Access's TableDef.Indexes"
        Debug.Print ""
        Debug.Print "That's why your query is fast!"
    Else
        Debug.Print "‚úì This is a LOCAL table"
        Debug.Print "No indexes should mean slow queries..."
    End If
End Sub

'Test 3: Force a Full Table Scan (Prove No Index)

Public Sub ProveNoIndexWithMultipleDates()
    Debug.Print "‚ïê‚ïê‚ïê MULTIPLE DATE TEST (No Cache) ‚ïê‚ïê‚ïê"
    Debug.Print ""
    Debug.Print "Testing different dates to rule out caching..."
    Debug.Print ""
    
    ' Test 5 different random dates
    Dim testDates As Variant
    testDates = Array( _
        "05-Jan-2025", _
        "10-Jan-2025", _
        "15-Jan-2025", _
        "20-Jan-2025", _
        "25-Jan-2025" _
    )
    
    Dim totalTime As Double
    totalTime = 0
    
    Dim testDate As Variant
    For Each testDate In testDates
        Dim startTime As Double
        startTime = Timer
        
        Dim rs As ADODB.Recordset
        Set rs = CurrentProject.Connection.Execute( _
            "SELECT COUNT(*) FROM BonyStatement WHERE ValueDate = #" & testDate & "#")
        
        Dim queryTime As Double
        queryTime = Timer - startTime
        totalTime = totalTime + queryTime
        
        Debug.Print "Date: " & testDate & " | Rows: " & Format(rs(0).Value, "#,##0") & _
                   " | Time: " & Format(queryTime, "0.000") & " sec"
        
        rs.Close
    Next
    
    Dim avgTime As Double
    avgTime = totalTime / 5
    
    Debug.Print ""
    Debug.Print "Average query time: " & Format(avgTime, "0.000") & " seconds"
    Debug.Print ""
    
    If avgTime < 1 Then
        Debug.Print "‚ö†Ô∏è MYSTERY: All queries fast with no index!"
        Debug.Print "Possible explanations:"
        Debug.Print "  1. Table is linked (has indexes on source DB)"
        Debug.Print "  2. Actual row count is much lower"
        Debug.Print "  3. Access doing something unexpected"
    Else
        Debug.Print "‚úì EXPECTED: Queries slow without index"
        Debug.Print "Your first query was probably cached"
    End If
End Sub

''Test 4: Database File Location


Public Sub CheckDatabaseLocation()
    Debug.Print "‚ïê‚ïê‚ïê DATABASE FILE INFO ‚ïê‚ïê‚ïê"
    Debug.Print "Database path: " & CurrentDb.Name
    Debug.Print "Database size: " & Format(FileLen(CurrentDb.Name) / 1024 / 1024, "#,##0") & " MB"
    Debug.Print ""
    
    ' Estimate expected size
    Dim rs As ADODB.Recordset
    Set rs = CurrentProject.Connection.Execute("SELECT COUNT(*) FROM BonyStatement")
    Dim rowCount As Long
    rowCount = rs(0).Value
    rs.Close
    
    ' Very rough estimate: ~200 bytes per row on average
    Dim expectedSizeMB As Long
    expectedSizeMB = (rowCount * 200) / 1024 / 1024
    
    Debug.Print "Rows: " & Format(rowCount, "#,##0")
    Debug.Print "Expected DB size: ~" & Format(expectedSizeMB, "#,##0") & " MB (very rough)"
    Debug.Print ""
    
    If expectedSizeMB > 1000 And FileLen(CurrentDb.Name) / 1024 / 1024 < 500 Then
        Debug.Print "‚ö†Ô∏è DB size much smaller than expected!"
        Debug.Print "Rows might not all be in this database"
    End If
End Sub

''Test 5: Definitive Full Table Scan

Public Sub ForceFullTableScan()
    Debug.Print "‚ïê‚ïê‚ïê FORCE FULL TABLE SCAN ‚ïê‚ïê‚ïê"
    Debug.Print ""
    Debug.Print "This query CANNOT use an index (if one exists)..."
    Debug.Print "If this is slow, there's no index. If fast, something else is going on."
    Debug.Print ""
    
    Dim startTime As Double
    startTime = Timer
    
    ' Use a function on ValueDate - this prevents index usage
    Dim rs As ADODB.Recordset
    Set rs = CurrentProject.Connection.Execute( _
        "SELECT COUNT(*) FROM BonyStatement " & _
        "WHERE DateValue(ValueDate) = #13-Jan-2025#")
    
    Dim scanTime As Double
    scanTime = Timer - startTime
    
    Debug.Print "Rows found: " & Format(rs(0).Value, "#,##0")
    Debug.Print "Time: " & Format(scanTime, "0.00") & " seconds"
    Debug.Print ""
    
    rs.Close
    
    ' Now compare to simple query
    startTime = Timer
    Set rs = CurrentProject.Connection.Execute( _
        "SELECT COUNT(*) FROM BonyStatement " & _
        "WHERE ValueDate = #13-Jan-2025#")
    
    Dim simpleTime As Double
    simpleTime = Timer - startTime
    
    Debug.Print "Simple query time: " & Format(simpleTime, "0.00") & " seconds"
    Debug.Print ""
    
    If scanTime > 10 And simpleTime < 2 Then
        Debug.Print "‚úì CONFIRMED: There IS an index working!"
        Debug.Print "  (Even though it doesn't show in Indexes collection)"
        Debug.Print "  Most likely: Linked table with index on source DB"
    ElseIf scanTime > 10 And simpleTime > 10 Then
        Debug.Print "‚úì CONFIRMED: No index - both queries slow"
        Debug.Print "  Your earlier fast result was probably cached"
    Else
        Debug.Print "‚ö†Ô∏è Both queries fast (< 2 sec) on 1.5M rows with no index"
        Debug.Print "  This is IMPOSSIBLE - something unusual is happening"
    End If
End Sub

''TEST SLEEVE

Public Sub RunFullDiagnostics()
    Debug.Print "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    Debug.Print "FULL DIAGNOSTIC SUITE"
    Debug.Print "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    Debug.Print ""
    
    Call GetTrueRowCount()
    Debug.Print ""
    Debug.Print "----------------------------------------"
    Debug.Print ""
    
    Call CheckIfLinkedTable()
    Debug.Print ""
    Debug.Print "----------------------------------------"
    Debug.Print ""
    
    Call CheckDatabaseLocation()
    Debug.Print ""
    Debug.Print "----------------------------------------"
    Debug.Print ""
    
    Call ProveNoIndexWithMultipleDates()
    Debug.Print ""
    Debug.Print "----------------------------------------"
    Debug.Print ""
    
    Call ForceFullTableScan()
    Debug.Print ""
    Debug.Print "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
End Sub
```

---

## ü§î **What I Suspect**

Based on "no indexes" + "fast query", one of these MUST be true:

### **Hypothesis 1: Linked Table** (Most Likely)
```
Your BonyStatement is a linked table pointing to:
‚îú‚îÄ SQL Server database (with indexes)
‚îú‚îÄ Another Access database (with indexes)
‚îî‚îÄ ODBC source (with indexes)

Access can't see remote indexes in TableDef.Indexes
But the remote database uses them for queries
Result: Fast queries, no visible indexes
```

### **Hypothesis 2: Much Fewer Rows**
```
You don't actually have 1.5M rows in THIS table:
‚îú‚îÄ Maybe 1.5M is across ALL years/tables
‚îú‚îÄ This specific table: 50K rows
‚îî‚îÄ Result: Fast even without index
```

### **Hypothesis 3: Partitioned Data**
```
Maybe you have multiple tables:
‚îú‚îÄ BonyStatement_2023 (500K rows)
‚îú‚îÄ BonyStatement_2024 (500K rows)
‚îú‚îÄ BonyStatement_2025 (50K rows) ‚Üê You're querying this one
‚îî‚îÄ Total: 1.5M, but you only query current year
```

### **Hypothesis 4: Cached Results**
```
First query was slow (you didn't notice)
Now Access has results cached in memory
Result: Subsequent queries instant